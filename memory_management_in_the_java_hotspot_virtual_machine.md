# Memory Management in the Java HotSpot™ Virtual Machine

## 1 소개

Java™ 2 플랫폼인 Standard Edition(J2SE™)의 한 가지 장점은 자동 메모리 관리를 수행하여 개발자를 명시적 메모리 관리의 복잡함으로부터 보호한다는 것입니다.

이 백서에서는 Sun의 J2SE 5.0 릴리스에서 Java HotSpot Virtual Machine (JVM)의 메모리 관리에 대해 광범위하게 설명합니다. 메모리 관리를 수행하는 데 사용할 수 있는 가비지 컬렉터(Garbage Collector)에 대해 설명하고, 가비지 컬렉션 선택, 설정과 메모리 크기 구성에 대한 몇 가지 조언을 제공합니다. 또한 가비지 컬렉터 동작에 영향을 미치는 가장 일반적으로 사용되는 몇 가지 옵션을 나열하고 보다 자세한 설명서에 대한 수많은 링크를 제공하는 리소스 역할도 합니다.

섹션 2는 자동 메모리 관리 개념을 처음 접하는 독자들을 위한 것입니다. 이 자료에는 이러한 관리의 이점과 프로그래머가 데이터를 위한 영역을 명시적으로 할당 해제해야 하는 이점에 대한 간략한 설명이 포함되어 있습니다. 그런 다음 섹션 3은 일반적인 가비지 컬렉션 개념, 설계 선택 및 성능 측정 기준에 대한 개요를 제시합니다. 또한 일반적으로 사용되는 메모리를 객체의 예상 수명을 기반으로 세대(Generations) 라고 하는 다른 영역으로 구성되는 것에 대해 소개합니다. 이러한 세대별 분리는 광범위한 애플리케이션에서 가비지 컬렉션 중지 시간과 전체 비용을 줄이는 데 효과적이라는 것이 입증되었습니다.

본 문서의 나머지 부분에서는 HotSpot JVM 관련 정보를 제공한다. 섹션 4에서는 J2SE 5.0 업데이트 6에 새로 추가된 것을 포함하여 사용 가능한 4개의 가비지 컬렉터를 설명하고 있으며, 모든 가비지 컬렉터가 사용하는 세대 메모리 조직을 문서화합니다. 각 컬렉터에 대해 섹션 4는 사용되는 컬렉션 알고리즘의 유형을 요약하고 해당 가비지 컬렉터를 선택하는 것이 적절한 시기를 지정합니다.

섹션 5에서는 애플리케이션이 실행 중인 플랫폼 및 운영 체제를 기반으로 (1) 가비지 컬렉터, 힙 크기 및 HotSpot JVM(클라이언트 또는 서버)의 자동 선택과 (2) 사용자가 지정한 원하는 동작을 기반으로 한 동적 가비지 컬렉션 튜닝을 결합한 새로운 기술을 설명합니다. 이 기술을 ergonomics 이라고 합니다.

섹션 6에서는 가비지 컬렉션를 선택하고 구성하기 위한 권장 사항을 제공합니다. 또한 `OutOfMemoryError`에 대해 수행할 작업에 대한 조언을 제공합니다. 섹션 7은 가비지 컬렉션 성능을 평가하는 데 사용할 수 있는 몇 가지 도구를 간략하게 설명하고 섹션 8은 가비지 컬렉터 선택 및 동작과 관련하여 가장 일반적으로 사용되는 명령줄 옵션을 나열합니다. 마지막으로, 섹션 9는 본 논문에서 다루는 다양한 주제에 대한 자세한 설명서에 대한 링크를 제공합니다.

## 2 명시적 vs. 자동 메모리 관리

메모리 관리는 할당된 객체가 더 이상 필요하지 않은 경우를 인식하여 해당 객체에 사용되는 메모리를 할당 해제하고 이후 할당 받을 수 있도록 하는 프로세스입니다. 일부 프로그래밍 언어에서 메모리 관리는 프로그래머의 책임입니다. 이 작업의 복잡성으로 인해 예기치 않거나 잘못된 프로그램 동작 및 충돌이 발생할 수 있는 많은 일반적인 오류가 발생합니다. 그 결과 상당한 시간이 디버깅에 소비되고 이러한 오류를 수정하기 위해 노력해야 합니다.

명시적 메모리 관리가 있는 프로그램에서 자주 발생하는 한 가지 문제는 댕글링 포인터 (Dangling Pointer) 입니다. 다른 객체에 참조가 남아 있는 객체의 영역을 할당 취소할 수 있다는 것입니다. 참조가 있는 객체가 원래 객체에 액세스하려고 했지만 기존의 영역이 새 객체에 재할당된 경우 결과는 예상할 수 없으며 의도한 결과가 아닙니다.

명시적 메모리 관리의 또 다른 일반적인 문제는 메모리 누수입니다. 이러한 누수는 메모리가 할당되고 더 이상 참조되지 않지만 해제되지 않을 때 발생합니다. 예를 들어, 링크된 목록에 의해 사용된 영역을 확보하려고 하지만 목록의 첫 번째 요소만 할당 취소하는 실수를 저지른 경우, 나머지 목록 요소는 더 이상 참조되지 않지만 프로그램의 범위를 벗어나 사용되거나 복구할 수 없습니다. 누수가 어느정도 발생하면 사용 가능한 메모리가 모두 소모될 때까지 메모리가 누수됩니다.

특히 대부분의 현대 객체 지향 언어에서 현재 일반적으로 사용되는 메모리 관리에 대한 대체 방법은 가비지 컬렉터라는 프로그램에 의한 자동 관리입니다. 자동 메모리 관리를 통해 인터페이스의 추상화를 개선하고 코드를 더욱 신뢰할 수 있습니다.

여전히 참조되는 객체는 사용하고 있는 객체로 간주하기 때문에 가비지 컬렉션이 발생하지 않습니다. 이 것은 댕글링 포인터 문제를 방지해줍니다. 가비지 컬렉션은 더 이상 참조되지 않는 모든 메모리를 자동으로 확보하므로 위에서 설명한 메모리 누수 문제도 해결합니다.

## 3 가비지 컬렉션 개념

가비지 컬렉터는 다음과 같은 역할을 담당합니다.

- 메모리 할당
- 참조된 모든 객체가 메모리에 남아 있는지 확인
- 더 이상 참조되지 않는 객체의 메모리 반환

참조되는 객체는 라이브(live)라고 합니다. 더 이상 참조되지 않는 객체는 죽은 것(dead)으로 간주되며 가비지(garbage)라고 합니다. 이러한 객체에서 사용되는 영역을 찾고 회수하는 프로세스를 가비지 컬렉션이라고 합니다.

가비지 컬렉션은 많은 메모리 할당 문제를 해결하지만 전부 해결하지는 못합니다. 예를 들어 객체를 무한정 만들고 참조를 유지하여 사용 가능한 메모리가 더 이상 없는 상태를 만들 수 있습니다. 또, 가비지 컬렉션은 시간과 리소스를 소모하는 복잡한 작업입니다.

메모리를 구성하고 영역을 할당 및 해제하는 데 사용되는 정확한 알고리즘은 프로그래머에게 공개되지 않습니다. 할당되는 영역은 일반적으로 힙(heap)이라고 메모리 풀입니다.

가비지 컬렉션 시기는 가비지 컬렉터의 몫입니다. 일반적으로 전체 힙이나 힙의 하위 부분이 가득 차거나 점유율이 임계값 백분율에 도달하면 가비지가 수집됩니다.

힙에서 특정 크기의 사용되지 않는 메모리 블록을 찾아 할당 요청을 수행하는 작업은 어려운 작업입니다. 대부분의 동적 메모리 할당 알고리즘의 주된 문제는 할당과 해제를 모두 효율적으로 유지하면서 단편화(fragmentation)를 방지하는 것입니다. (하단 참조)

### 바람직한 가비지 컬렉터의 특성

가비지 컬렉터는 안전하고 포괄적이어야 합니다. 즉, 라이브 데이터는 절대 잘못 해제되어서는 안 되며, 가비지는 일정 수집 주기 동안 반환되지 않은 상태로 유지되어서는 안 됩니다.

또한 가비지 컬렉터는 긴 일시 중지를 발생시키지 않고 효율적으로 작동하는 것이 바람직합니다. 그러나 대부분의 컴퓨터 관련 시스템과 마찬가지로 시간, 메모리 영역 및 빈도 간에 종종 절충 방안이 있습니다. 예를 들어 힙 크기가 작으면 수집은 빠르지만 힙은 더 빨리 채워지기 때문에 더 자주 수집해야 합니다. 반대로, 큰 힙은 채우는 데 더 오래 걸리기 때문에 수집 빈도가 줄어들지만 수집하는 데에 더 오래 걸릴 수 있습니다.

또 다른 가비지 컬렉터의 특성은 단편화의 제한이다. 가비지에 대한 메모리가 확보되면 사용 가능한 영역이 다양한 영역에서 작은 덩어리로 나타나므로 큰 객체의 할당을 위해 사용할 연속된 영역이 없을 수 있습니다. 단편화를 제거하는 한 가지 접근 방식은 압축(compaction)이라고 하며, 아래의 다양한 가비지 컬렉터 디자인 선택 항목에서 설명합니다.

확장성 또한 중요합니다. 할당이 다중 스레드 애플리케이션의 확장성에 대한 병목현상이 되어서는 안 되며, 가비지 컬렉션 또한 이러한 병목현상이 되어서는 안 됩니다.

### 디자인 선택

가비지 컬렉션 알고리즘을 설계하거나 선택할 때 여러 옵션을 고려해야 합니다.

- 직렬 vs 병렬

  직렬 컬렉션의 경우, 한 번에 한 가지 일만 할 수 있습니다. 예를 들어 여러 프로세서가 사용 가능한 경우에도 컬렉션을 수행하는 데 하나만의 프로세서만 사용됩니다. 병렬 컬렉션을 사용하면 가비지 컬렉션이 여러 프로세서에서 동시에 실행됩니다. 동시 연산을 사용하면 컬렉션을 보다 빠르게 수행할 수 있지만, 복잡한 연산과 단편화가 발생할 수 있습니다.

- Concurrent(동시) vs Stop-the-world(일시 정지)

  STW(Stop-the-world) 가비지 컬렉션을 수행하면 응용 프로그램의 실행이 완전히 일시 정지됩니다. 그리고, Concurrent 가비지 컬렉션은 응용 프로그램과 동시에 실행할 수 있습니다. 수집 중에 힙이 고정되고 객체가 변경되지 않기 때문에 STW 가비지 컬렉션은 Concurrent 가비지 컬렉션보다 간단합니다. 단점은 일부 응용 프로그램이 일시 정지되는 것이 바람직하지 않을 수 있다는 것입니다. 가비지 컬렉션을 응용 프로그램 실행 중에 수행할 경우 일시 정지 시간이 짧아지지만 가비지 컬렉터는 응용 프로그램에 의해 동시 업데이트될 수 있는 객체에 작동하므로 주의해야 합니다. Concorrent 가비지 컬렉션은 더 큰 힙 크기가 필요하고 약간의 오버헤드가 추가됩니다.

- 압축 vs 비 압축 vs 복사

  압축 방식의 가비지 콜렉터는 메모리의 어떤 객체가 사용중이고 어떤 객체가 가비지인지 결정한 후 메모리를 압축하여 모든 사용중인 객체를 이동하고 나머지 메모리를 회수합니다. 압축 후 첫 번째 여유 위치에 새 객체를 할당하는 것은 쉽고 간단합니다. 압축 방식의 컬렉터와 달리 비 압축 방식의 컬렉터는 가비지 객체가 사용하는 공간을 즉시 해제합니다. 즉, 압축 방식처럼 큰 영역을 만들기 위해 모든 사용중인 객체를 이동하지 않습니다. 가비지 컬렉션이 더 빨리 완료된다는 장점이 있지만, 잠재적인 단편화가 발생할 수 있습니다. 일반적으로 압축된 힙보다 할당 해제 기능이 있는 힙에서 할당하는 것이 더 비쌉니다. 일반적으로 압축된 힙에 할당하는 것 보다 할당 해제된 위치에 새로 할당하는 방법이 더 어렵습니다. 새 객체를 수용할 수 있을 만큼 충분히 큰 연속 메모리 영역을 힙에서 검색해야 할 수도 있습니다. 세 번째 대안은 사용중인 객체를 다른 메모리 영역으로 복사(또는 제거)하는 복사 방식의 가비지 컬렉터입니다. 장점은 해당 영역이 비어 있는 것으로 간주되어 빠르고 쉽게 할당에 사용할 수 있다는 것입니다. 그러나 복사에 필요한 추가 시간이 발생하고, 추가 공간이 필요할 수도 있습니다.

### 성능 지표

가비지 컬렉터의 성능을 평가하는 데 사용되는 지표는 다음과 같습니다.

- Throughput - 장시간에 걸친 가비지 컬렉션에 소비되지 않은 총 시간의 백분율
- Garbage collection overhead - 처리량의 역수치, 즉 총 가비지 컬렉션 시간의 백분율
- Pause time - 가비지 컬렉션이 발생하는 동안 응용프로그램 실행이 중지되는 시간
- Frequency of collection - 애플리케이션 실행 중, 가비지 커렉션이 발생하는 빈도
- Footprint - 힙 크기와 유사한 크기의 척도
- Promptness - 객체가 가비지가 되는 시점과 메모리를 사용할 수 있게 되는 시점 사이의 시간

대화형 응용 프로그램은 짧은 일시 중지 시간이 필요할 수 있지만 전체 실행 시간은 대화형 응용 프로그램이 아닌 응용 프로그램에 더 중요합니다. 실시간 응용 프로그램은 가비지 컬렉션 일시 중지와 가비지 컬렉터에 소요된 시간의 비율에 대해 약간의 상한선을 요구합니다. 작은 설치 공간은 개인용 컴퓨터 또는 임베디드 시스템에서 실행되는 애플리케이션의 주요 관심사가 될 수 있습니다.

### 세대 컬렉션

*세대 컬렉션*이라고 불리는 기술을 사용할 때, 객체를 서로 다른 *세대*로 분류하고, 매모리는 객체를 수용하는 별도의 풀로 분할됩니다. 가장 널리 사용되는 구성은 두 세대 분류하는데, 하나는 어린 객체용이고 다른 하나는 오래된 객체용입니다.

서로 다른 세대의 가비지 컬렉션을 수행하기 위해 서로 다른 알고리즘을 사용할 수 있으며, 각 알고리즘은 각 세대의 공통적으로 관찰되는 특성을 기반으로 최적화됩니다. 세대 가비지 컬렉션은 Java를 포함한 여러 프로그래밍 언어로 작성된 응용 프로그램에 대해 *약한 세대 가설*로 알려진 다음과 같은 관찰을 이용합니다.

- 대부분의 할당된 객체는 오래 참조되지 않음
- 오래된 객체에서 어린 객체로의 참조는 거의 없음

젊은 세대 컬렉션(Young Generation)은 상대적으로 자주 발생하고 효율적이며 빠릅니다. 젊은 세대 공간은 대개 작고 더 이상 참조되지 않는 많은 개체를 포함할 가능성이 있기 때문입니다.

일부 젊은 세대 컬렉션에서 처리되지 않은 객체들은 결국 오래된 세대(Old Generation)로 승격되거나 유지됩니다(그림 1 참조). 이 세대는 전형적으로 젊은 세대보다 더 크고 점유율이 더 느립니다. 따라서 오래된 세대 컬렉션은 가끔 발생하지만 완료하는 데 시간이 상당히 오래 걸립니다.

![Figure 1. Generatonal garbage collection](./images/Figure_1.png)

젊은 세대를 위해 선택된 가비지 컬렉션 알고리즘은 젊은 세대 수집이 빈번하기 때문에 일반적으로 속도를 중요시합니다. 반면에 오래된 세대는 일반적으로 공간 효율적인 알고리즘에 의해 관리되는데, 오래된 세대는 힙의 대부분을 차지하고 오래된 세대 컬렉션 알고리즘은 낮은 가비지 밀도에서 잘 작동해야 하기 때문이다.

**추가 예정**

## 참고

- [공식 문서](https://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf)
